#MySQL/Redo日志
## 什么是redo日志
首先要明白，如果我们在MySQL中修改了某个表的中的数据，并非立即将这些要更新的数据写入到数据库，而是将修改写入到Buffer Pool中，再刷新回磁盘
> 具体可看[[BufferPool]]

那么此时就有可能出现这样一种情况，在一个事务中，如果我们修改了数据库，但是数据库发生了崩溃，导致内存丢失，那么我们对数据库的修改也就会丢失
**而redo日志会把对数据库的修改记录下来，一旦数据库崩溃，MySQL就会采用该日志进行恢复，因此，redo日志解决的是事务的持久性**
此外，还有以下两种情况：
* MySQL是以页为单位进行IO交互的，如果我们只是修改了一个字段，就把一个完整的页面刷回去，显然太浪费
* 一个事务中的修改可能涉及多个页面，而每个页面并不是挨着的，因此就会涉及随机IO，这样显然对性能影响很大
> [!NOTE]
> redo日志只会记录修改了什么，而不是整个页面的数据，节约了空间
> redo日志是顺序写入磁盘的，使用顺序IO
## redo日志格式
MySQL为redo日志设计了多种格式，目的是为了满足不同场景，下面先来看看最通用的格式
![image.png](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202401102157726.png)
* type：日志类型
* space ID：表空间ID，用来寻找对应的表
* page number：页号，用来寻找对应的页
* data：日志的具体内容
> [!NOTE]
> 简单来说，当我们向其中一个表插入一条数据，redo日志就会用这样的形式进行记录：向 XX表的XX页insertXXX

但是，有时候我们的修改并不是这么简单，它可能涉及对多个页甚至多个表进行修改；比如说，当我们要插入一条数据，但是B+树对应页面空间不够，此时就会产生页的分裂，那我们就不仅仅要记录插入的页，还需要记录被修改的页，以及目录页中的数据，因此这样的redo日志需要修改多个字段，会复杂很多，这里不再介绍，有兴趣请看相关书籍😂
## 一组redo日志-Mini Transaction
就像上面提到的，尽管我们可能只是插入一条数据，但是依然可能涉及到B+树的页面分裂，因此我们的redo日志可能是这样的：
* 向页B插入数据XXX
* 修改页A的记录(因为发生了页分裂，原来的页空间不够)
* 修改页A和页B的目录页中的记录
而这几条redo日志显然应该**保持原子性**，因此MySQL中会把这一组redo日志的操作称为**Mini-Transaction简称mtr**
## Redo日志是如何写入的


