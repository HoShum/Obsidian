#MySQL/BufferPool
# What & Why
其实Buffer Pool就是缓冲区，本质就是MySQL向操作系统申请的一片连续的内存空间
**那为什么需要Buffer Pool呢？**
因为MySQL是以页为单位进行加载的，就是说，即使我们使用`SELECT * FROM table LIMIT 1`来查询一条记录，MySQL也会先把该记录所在的页加载的内存中进行处理
而如果我们查询的数据分散在多个页中，MySQL就需要读取多个页的数据，要知道IO磁盘读取数据是很慢的，因此使用缓存区对数据进行缓存可以提高查询的性能
提高缓存性能的核心就是，提高命中率
# Buffer Pool结构
一块Buffer Pool由控制块和缓冲页组成，如下图所示：
![](https://cdn.nlark.com/yuque/0/2023/png/27500701/1694339472612-081a9a86-b0da-408f-8282-8d14ebddb230.png)
- 控制块：用来存储缓冲页的一些控制信息，比如它是否为脏页，它所指向的缓冲页等
- 缓冲页：可以理解为就是一块内存空间
一个控制块对应一个缓冲页
# 链表
光有控制块和缓冲页还不行，MySQL需要知道哪些缓冲页是空闲（未使用），哪些是刷新的，因此MySQL还设计了以下几个链表去管理
实际上链表的种类很多，这里只列举了重点的几个
## free链表
### 结构
当我们使用SQL去查询数据时，MySQL需要找到“空闲的页”来接收这些数据，而为了提高找到空闲页的效率，MySQL设计了free链表来管理目前Buffer Pool中空闲的页，然后从该链表中读取空闲页，其结构如下：
![](https://cdn.nlark.com/yuque/0/2023/png/27500701/1694340471486-45a19d33-3de6-48da-9dc7-224d9a53f70b.png)

- 请注意，链表的每个节点都是**控制块**，而不是缓冲页，链表关联了控制块，就可以根据控制块的信息去找到对应的缓冲页
- 每个节点之间组成了双向链表
- 链表有一个头节点，用来关联链表，头节点会存放在单独的内存空间，而不是在Buffer Pool的内存空间中
### 哈希处理
另外，为了更快地找到读取到的页是否已经被加载到Buffer Pool中了，MySQL还会对缓冲页进行哈希处理，即根据**表空间号 + 页号**来当成key，对应的缓冲页作为value，保存到哈希表中
### 如何读取
当我们要从数据库读取数据页时，会先从哈希表中判断该页是否已经存在，若存在，则直接读取，若不存在，则从free链表中找到一个缓冲页来接收这些数据，当加载完数据后，就会把该控制块从free链表中移除
## flush链表
当我们修改了某个页的数据时，该页的数据就和数据库中的数据不一致，被视为“脏页”，但MySQL并不会立即刷新这些脏页回数据库，而是先用一个链表管理起来，该链表就是flush链表，其结构和free链表一致
关于刷新时机，后续会记录
## LRU链表
LRU，即Latest Recently Use，最近最频繁使用，是一种常见的内存淘汰策略，即当内存不足时，只保存最近使用最频繁的数据，而淘汰最晚使用最少的数据
简单的LRU链表非常容易实现，只需要把新来的数据插到链表头部，而当内存不足时，再把链表尾部的数据淘汰即可；
但是MySQL中会存在以下情况，而导致如果使用这种简单的LRU策略的话，会出现一些问题
### Case1 预读机制
简单来说，就是MySQL为了避免频繁地读取IO，会有一种机制，把预先可能会读取的页提前加载到内存，如当发生以下情况时：
- 当顺序访问某个区（extend）的页面超过阈值时，会触发预读，把该区的下一个区的全部页面加载到内存中
- 当某个区的连续13个页面被加载到内存（可以是随机读取），就会触发把本区中的所有页面都加载到内存中
以上的读取都是异步的，会使用另一个线程执行，而不影响主线程
**发生预读会影响什么？**
会把预读的页都放到LRU链表的头部，而挤掉尾部的页，大大降低命中率
### Case2 全表扫描
我们有时候可能会写一些造成全表扫描的SQL语句（例如没有建立索引，没有使用WHERE条件进行过滤等），当发生全表扫描时，会把全表所有的页都加载到内存中进行处理，造成大量的IO；
更有甚者，如果表的数据较多，根本无法一次性加载完所有的页，那就可能会导致分批次进行加载，进一步增加IO，严重影响性能
此外，当发生全表扫描时，采用简单的LRU链表，会导致链表迅速被全表扫描的数据所占据，而往往这种全表扫描可能只发生一次，这种情况下， 缓存相当于**失效！**
因此，我们写SQL语句时，也应该尽力避免出现全表扫描的情况！
### 改进后的LRU链表
#### 1、分区
MySQL采用了分区机制，把LRU链表分为`young`区和`old`区，其中young区存放**热数据**，而old区存放冷数据，其结构如下：
![](https://cdn.nlark.com/yuque/0/2023/png/27500701/1694343517489-24716032-6da7-4e8f-b53e-473aa508d485.png)
- 当初次加载页面到内存时，会先把页面放到old区域，而只有当后续进行访问时，才会把页面放到young区域；这样改进后，如果发生了预读，预读的页面后续并没有被访问，就会逐步在old区域中被淘汰
- 控制块会记录页面的第一次访问时间和后续访问时间，如果时间的间隔在规定时间内，就不会把它移动到young区域，这样可以有效避免发生全表扫描时把热数据都淘汰掉
哪怕我们只是读取一个页面中的一条数据，MySQL也会当成我们是在访问该页，因此设置间隔时间很有必要
#### 2、减少移动
链表的移动也是需要耗费时间的，如果我们每访问一次页面就把该页移动到头部，那么就会导致链表的调整非常频繁，而为了降低移动的频率，MySQL规定只有当访问young区域后**3/4**的页面时，才会移动该页面到头部
实际上，上述说到的young/old区划分比例等参数都是可以自己修改的，有需要再看书即可