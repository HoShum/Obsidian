# 浅谈动态规划

## 背景

动态规划可以算是力扣中比较难的一类题目了，而恰逢今天看到了一篇写得不错的文章，于是在它的基础上，结合自己的理解，写下这篇文档

> [你管这破玩意叫动态规划 (无聊的闪客)](https://mp.weixin.qq.com/s/_XS3nd-ipnkhYk_5X_ppSQ)

## 从高斯的故事讲起

不少人都听过数学王子高斯曾经巧算1+2+3+...+100的故事

而学习过高中数学都知道，这其实就是一种等差数列，公差为1，因此结合公式可以轻易算出结果为5050

但是如果我们换个角度，假设你已经知道`1+2+3+...99`的值为多少，那你是否能算出答案呢？很简单，只要在这个值的基础上加100即可

如果我们用数列去代表每一项的值，那么a(1)=1，a(2)=2，a(3)=3，....，a(n)=n，不难得出以下推论：

​											$$a(n)=a(n-1)+1$$

这就是数学上的递推公式，只要我们得到a(1)的值，我们就可以一直递推上去得到a(n)的值，从而得到S(n)的值，而这就是**最基本的动态规划思想**，通过子问题可以推导出结果

## 经典动态规划题目-爬楼梯

题目是这样的，假设现在有个10级的楼梯，你从下往上走，每一步只能跨一级或者两级，问：一共有多少种走法？

如果没接触过动态规划，那么当思考这个问题时，很容易陷入穷举的思想，因为你会去想，假如我每次都跨一级，或者每次都跨两级...

但是我们倒过来想，假设现在我们已经知道有9级一共有多少种走法，那么10级自然是9级的基础上+1；如果我们已经知道8级有多少种走法，那么9级自然是8级的基础上+2

如果用一个公式来表示的话，就是$F(n)=F(n-1)+F(n-2)$，其中$F(n)$表示只跨一级，$F(n-2)$表示跨两级

但此时又会有一个问题，就是当n=2或n=1怎么办？其实这就涉及到一个**边界问题**了，解决动态规划的其中一个重点就是找到边界，因为只有当找到边界，我们才可以利用递推公式一直往上推导；而在爬楼梯这个题目中，显然，当n=1时，F(1)=1，当n=2时，F(2)=2

而这里又引出三个概念：

* **最优子结构**：$F(n-1)$和$F(n-2)$就是$F(n)$的最优子结构，因为$F(n)$就是由这两个子问题推导出来
* **转态转移方程**：也被称为递推公式，$F(n)=F(n-1)+F(n-2)$
* **边界问题**：就是$F(1)=1$，$F(2)=2$，只有找到边界，才可以找到推导的起点

那么如何用代码实现呢？

```java
public class Solution {
    public int climbStairs(int n) {
		if (n = 1) {
            return 1;
        }
        if (n = 2) {
			return 2;
        }
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
}
```

这样的代码很容易想到，但是它存在一个问题，比如当n=10时，它的函数调用栈如下：

<img src="https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202404101441400.png" alt="image-20240410144146318" style="zoom:70%;" />

显然，这样会有大量重复的计算，且函数调用栈非常深，它的时间复杂度为$O(2^N)$，因为每个节点都有两个分叉，一旦数据量大，会非常影响性能

如果想优化一下，最简单的办法就是使用一个哈希表去记录每个节点的值，如果存在，则不再计算

**有没有更好的办法呢？**

答案是肯定的，此时就需要用到动态规划的思想了。实际上你根据递推公式会发现，每个节点都由前两个节点推导出来，因此只需要记录两个节点，然后动态修改即可，代码如下：

```java
public class Solution {
    public int climbStairs(int n) {
        int f1, f2, result = 0;
        for (int i = 1; i <= n; i++) {
            if (i == 1) {
                f1 = 1;
                continue;
			}
            if (i == 2) {
                f2 = 2;
                continue;
            }
            result = f1 + f2; //动态规划的精髓
        }
        return result;
    }
}
```

此时的时间复杂度是$O(n)$，空间复杂度则是$O(1)$