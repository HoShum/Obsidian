# 动态规划套路

## 什么才能用动态规划

首先要明白，计算机解决问题的方式永远只有一个，就是穷举，而动态规划不过是在穷举的基础上，利用一些巧妙的办法去较少计算机穷举的数量]

### 最优子结构

一个问题是否属于动态规划问题，首先要看它是否**符合最优子结构**

所谓的最优子结构，就是指问题的最优解可以由**子问题**的最优解推导出来

* 比如说要求一颗二叉树中的最大值的节点，那我们只要得出根节点左右两个子节点的最大值即可得出
* 比如说经典的凑硬币问题，假设金额是10，我们只要得出金额为9时的值，就可以推导出来

但是符合最优子结构只是一个**必要条件**，比如说求一颗二叉树的最大值我们肯定用不到动态转移方程，因为它没有**重叠子问题**，因此当一个问题不仅符合最优子结构，还具有重叠子问题，我们就可以尝试推导出**状态转移方程**，并使用动态规划去解决

### 如何列出状态转移方程

* 确定base case：即常说的边界条件，因为动态规划问题通常是从小问题向大问题推导的，因此需要一个**起点**
* 确定**状态**，即原问题和子问题中会发生变化的变量，比如说凑硬币问题中，硬币的面额是恒定的，而变化的是金额
* 确定**选择**，即导致**状态变化**的行为，比如说凑硬币问题中，为什么金额会变化呢？因为你每次取的硬币面额不一样
* **明确dp函数的意义**，这一点非常重要



## 经典问题-凑硬币

题目：给定一个硬币面额数组，比如[1,2,5]和一个金额，硬币数量任意，求可以达成给定金额的最小硬币数量

### 解法一  穷举

思路：

* 其实就是穷举，把所有的可能都试一遍，然后找到最硬币数量最少的解法

代码：

```java
public int solution1(int[] coins, int amount) {
    if (amount < 0) { //表示不取
        return -1;
    }
    if (amount == 0) { //表示取完后刚好和金额相等
        return 0;
    }
    int result = Integer.MAX_VALUE;
    for (int coin : coins) {
        int subSolution = dp1(coins, amount - coin);//表示取这个硬币
        if (subSolution == -1) { //说明取硬币已经大于金额，则不取
            continue;
        }
        //子问题中选择最优解
        result = Math.min(result, subSolution + 1); //+1表示加上这个硬币
    }
    return result == Integer.MAX_VALUE ? -1 : result; //如果值为Integer.MAX_VALUE则表示一个硬币都取不到
}
```

### 解法二  动态规划

思路：

* 