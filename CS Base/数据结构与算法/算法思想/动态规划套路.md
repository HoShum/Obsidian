# 动态规划套路

## 什么才能用动态规划

首先要明白，计算机解决问题的方式永远只有一个，就是穷举，而动态规划不过是在穷举的基础上，利用一些巧妙的办法去较少计算机穷举的数量]

### 最优子结构

一个问题是否属于动态规划问题，首先要看它是否**符合最优子结构**

所谓的最优子结构，就是指问题的最优解可以由**子问题**的最优解推导出来

* 比如说要求一颗二叉树中的最大值的节点，那我们只要得出根节点左右两个子节点的最大值即可得出
* 比如说经典的凑硬币问题，假设金额是10，我们只要得出金额为9时的值，就可以推导出来

但是符合最优子结构只是一个**必要条件**，比如说求一颗二叉树的最大值我们肯定用不到动态转移方程，因为它没有**重叠子问题**，因此当一个问题不仅符合最优子结构，还具有重叠子问题，我们就可以尝试推导出**状态转移方程**，并使用动态规划去解决

### 如何列出状态转移方程

* 确定base case：即常说的边界条件，因为动态规划问题通常是从小问题向大问题推导的，因此需要一个**起点**
* 确定**状态**，即原问题和子问题中会发生变化的变量，比如说凑硬币问题中，硬币的面额是恒定的，而变化的是金额
* 确定**选择**，即导致**状态变化**的行为，比如说凑硬币问题中，为什么金额会变化呢？因为你每次取的硬币面额不一样
* **明确dp函数的意义**，这一点非常重要



## 经典问题-凑硬币

题目：给定一个硬币面额数组，比如[1,2,5]和一个金额，硬币数量任意，求可以达成给定金额的最小硬币数量

### 解法一  穷举

思路：

* 其实就是穷举，把所有的可能都试一遍，然后找到最硬币数量最少的解法

代码：

```java
public int solution1(int[] coins, int amount) {
    if (amount < 0) { //表示不取
        return -1;
    }
    if (amount == 0) { //表示取完后刚好和金额相等
        return 0;
    }
    int result = Integer.MAX_VALUE;
    for (int coin : coins) {
        int subSolution = dp1(coins, amount - coin);//表示取这个硬币
        if (subSolution == -1) { //说明取硬币已经大于金额，则不取
            continue;
        }
        //子问题中选择最优解
        result = Math.min(result, subSolution + 1); //+1表示加上这个硬币
    }
    return result == Integer.MAX_VALUE ? -1 : result; //如果值为Integer.MAX_VALUE则表示一个硬币都取不到
}
```

### 解法二  动态规划

思路：

* 对于这题来说，假如我们要求金额为10的解，其实只要知道金额为9的解，就可以推导出来，基于这个思路，不难想到用动态规划去解决
* 可以想到，dp数组的含义为，下标表示金额，dp[i]则表示该金额的最小硬币数量，即解
* 那边界值如何确定呢，显然dp[0]=0，至于其它，只要设定为一个**取不到**的值即可，后续需要可以通过这个值来判断是否一个硬币都没有，那么可以设定为**amount+1**
* 最后，状态转移方程为：$$dp[i] = min(dp[i], dp[i -coin] + 1)$$
  * min函数左边的dp[i]表示不取当前硬币的最优解
  * min函数右边的dp[i-coin]表示**刚好满足取当前硬币**时最优解，然后+1表示加上当前这个硬币

代码：

```java
public int solution2(int[] coins, int amount) {
    int[] dpArray = new int[amount + 1];
    Arrays.fill(dpArray, amount + 1);
    dpArray[0] = 0;
    for (int i = 1; i < dpArray.length; i++) {
        for (int coin : coins) {
            if (i - coin < 0) {
                continue;
            }
            dpArray[i] = Math.min(dpArray[i], dpArray[i - coin] + 1);
        }
    }
    return dpArray[amount] == amount + 1 ? -1 : dpArray[amount];
}
```

补充说明：

* 为什么dp数组的长度为amount+1？因为你最终要取dp[amount]为题解
* 为什么dp数组非dp[0]的初始值不能是0？因为假如为0的话，使用Math.min判断时就会有问题；而为什么不能为Integer.MAX_VALUE？因为状态转移方程会+1，这样会超过Integer的范围；而设定为amount+1则不会存在以上问题，因为题解的最大值也仅为amount