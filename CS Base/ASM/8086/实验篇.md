## 一、Debug的使用
输入`debug`进入debug模式，进入debug模式后，有以下几条命令需要学习：
* R：查看所有寄存器的数据
* D：查看内存的情况，可以指定内存位置查看，比如：`d 0000:0001`
* E：改写内存中的数据
	* 比如说，使用`e 0000:0000 AB CD 11 00`命令
	* 再使用`d 0000:0000`即可看到内存的数据发生变化
* A：写入汇编指令（代码）
	* 比如说，先输入`a 073F:0104`，**注意，这个是CS:IP的地址**
	* 然后就会允许你输入汇编代码，比如你可以继续输入`mov bx,ax`
	* 按回车停止输入后，输入`t`命令，**就会执行CS:IP执行的代码**
* T：结合A使用
* U：用来将内存中的机器指令翻译成汇编指令
	* 用上面的例子来说明的话，我们向073F:0104的地址写入了一段汇编指令，但是如果我们使用d去查看内存中的数据，就会发现都是二进制；而如果此时我们使用`u 073F:0104`命令的话，就会看到我们刚才输入的汇编指令，**注意，此时IP已经变成了0106**
```ad-note
title: 学到了什么？

* 程序代码本身也是加载到内存中执行，会有专门的机器码来表示
* 每执行一条指令，IP寄存器的值就会增加(取决于指令的长度)
```
## 二、运算指令
```ad-warning
注意，如果需要输入指令，首先需要输入a指令，才能输入汇编指令
```
### 2.1 mov
mov指令很简单，就有点类似于平时写代码的赋值语句，它有以下作用：
1. 将数值移动到寄存器中，如`mov ax,8`，就等价于`ax = 8`
2. 将寄存器中的值移动到寄存器中，如`mov ax,bx`，就等价于`ax = bx`
3. 将内存地址中的数据移动到寄存器中，如`mov ax,[0]`，即将第一个内存单元中的数据移动到寄存器ax中

除此之外， mov指令也可以移动寄存器**高位/低位**的数据，比如`mox al,8`，如果本来ax寄存器中的数据为1050H，则会变成1058H（左边为高位，右边为低位）
### 2.2 add、sub
add和sub指令也很简单，就是相加和相减指令，如：
* `add ax,8`，就等价于`ax += 8*
* `sub ax,bx`，就等价于`ax -= bx`

但是需要注意的是，如果相加后需要进位或者借位，会被舍弃，如：
**进位**
ax的值是FFFF，此时使用`add ax,1`，那么结果就为0000，因为实际结果是10000，但由于寄存器只能存放32位，因此最高位被舍弃
**借位**
ax的值是0FFF，此时使用`sub ax,F000`，那么结果就为1FFF，因为后三位FFF减000得到的依然是FFF，而最左边的0不够减F，因此借了一位变成10再去减F，得到1，于是结果变成1FFF
```ad-note
需要注意的是，ax、bx这类寄存器不能和ds段寄存器进行运算
```
