## 前置知识
* 8086CPU的寄存器为16位寄存器，其中高位寄存器和低位寄存器可以独立使用，比如AX可以拆分为各占8位的AH和AL寄存器
* 4个二进制代表一个16进制数，因此16位的寄存器用16进制表示就是4个16进制数
## 一、Debug的使用
输入`debug`进入debug模式，进入debug模式后，有以下几条命令需要学习：
* R：查看所有寄存器的数据
    * 除了查看寄存器的数据，也可以用来修改寄存器的值，比如`r ds`然后输入`:1000`即可修改
* D：查看内存的情况，可以指定内存位置查看，比如：`d 0000:0001`
* E：改写内存中的数据
	* 比如说，使用`e 0000:0000 AB CD 11 00`命令，再使用`d 0000:0000`即可看到内存的数据发生变化
	* 另外，使用e指定要修改的内存位置时，会提示`00.`，它表示的是当前偏移位置的值为00
* A：写入汇编指令（代码）
	* 比如说，先输入`a 073F:0104`，**注意，这个是CS:IP的地址**
	* 然后就会允许你输入汇编代码，比如你可以继续输入`mov bx,ax`
	* 按回车停止输入后，输入`t`命令，**就会执行CS:IP执行的代码**
* T：结合A使用
* U：用来将内存中的机器指令翻译成汇编指令
	* 用上面的例子来说明的话，我们向073F:0104的地址写入了一段汇编指令，但是如果我们使用d去查看内存中的数据，就会发现都是二进制；而如果此时我们使用`u 073F:0104`命令的话，就会看到我们刚才输入的汇编指令，**注意，此时IP已经变成了0106**
```ad-note
title: 学到了什么？

* 程序代码本身也是加载到内存中执行，会有专门的机器码来表示
* 每执行一条指令，IP寄存器的值就会增加(取决于指令的长度)
```
## 二、运算指令

```ad-warning
注意，如果需要输入指令，首先需要输入a指令，才能输入汇编指令
```
### 2.1 mov
mov指令很简单，就有点类似于平时写代码的赋值语句，它有以下作用：
1. 将数值移动到寄存器中，如`mov ax,8`，就等价于`ax = 8`
2. 将寄存器中的值移动到寄存器中，如`mov ax,bx`，就等价于`ax = bx`
3. 将内存地址中的数据移动到寄存器中，如`mov ax,[0]`，即将第一个内存单元中的数据移动到寄存器ax中

除此之外， mov指令也可以移动寄存器**高位/低位**的数据，比如`mox al,8`，如果本来ax寄存器中的数据为1050H，则会变成1058H（左边为高位，右边为低位）
### 2.2 add、sub
add和sub指令也很简单，就是相加和相减指令，如：
* `add ax,8`，就等价于`ax += 8`
* `sub ax,bx`，就等价于`ax -= bx`

但是需要注意的是，如果相加后需要进位或者借位，会被舍弃，如：
**进位**
ax的值是FFFF，此时使用`add ax,1`，那么结果就为0000，因为实际结果是10000，但由于寄存器只能存放32位，因此最高位被舍弃
**借位**
ax的值是0FFF，此时使用`sub ax,F000`，那么结果就为1FFF，因为后三位FFF减000得到的依然是FFF，而最左边的0不够减F，因此借了一位变成10再去减F，得到1，于是结果变成1FFF
```ad-note
需要注意的是，ax、bx这类寄存器不能和ds段寄存器进行运算
```
### 2.3 mul
该指令是乘法指令，跟加减指令稍有区别，乘法指令分为两种情况：
1. 两个都能用8位表示，则相乘后最多也不会超过16位（2个字节），即刚好一个寄存器能存下，则其中一个数会默认放在**AL**中，另一个则放在另一个8位寄存器或者内存单元中，结果会存放在**AX**寄存器中
2. 如果两个需要用16位来表示，则由于相乘后可能会超过16位，一个寄存器放不下，因此其中一个数默认会放在**AX**中，另一个则放在另一个16位寄存器或内存单元中，结果中的低位会存放在**AX**中，而高位则会存放在**DX**中

举一个例子，比如现在想实现`100*10`，那应该输入以下命令：
```asm fold
mov al, 64 这是十进制的100
mov bl, A 这是十进制的10
mul bl
```
得到的结果为AX=0x03E8(1000)
```ad-note
* 一个寄存器是2个字节，即16位，4个十六进制数
* 两个最大的8位FF相乘，结果是FE01，因此最多不会超过两个字节
* 两个最大的16位FFFF相乘，结果是FFFE0001，因此最多占用4个字节
```

### 2.4 div
该指令是除法指令，主要是分为两种情况：
1. 除数是8位，则被除数是16位，存在在AX；得到的结果最多为16位，AL存放商，AH存放余数
2. 除数是16位，则被除数是32位，存放在AX和DX中，其中DX存在高位，AX存放低位；得到的结果最多为32位，AX存放商，DX存放余数

举一个例子，比如现在想实现`1000 / 10` ，那么应该输入以下命令：
```asm fold
mov ax, 03E8 这个是十进制的1000
mov bx, A 这个是十进制的10
div bx
```
得到的结果为，AX=0064，即商为0x64（100）,余为0
## 三、逻辑运算指令
### 3.1 and、or
这两个指令分别是与运算和或运算，使用非常简单，需要注意的是，在debug模式下，需要输入十六进制，而非二进制，默认会跟AX寄存器进行运算
举个例子，比如想跟00001000进行与运算，只需要使用`and 8`即可
### 3.2 shl、shr
shl就是shift left，而shr就是shift right，即**移位**指令
使用很简单，比如我要将AX的值左移一位，使用以下指令：`shl ax,1` 即可
```ad-note
除此之外，还有`rol`指令和`ror`指令，分别代表循环左移和循环右移，即会将最左边的位移动到最右边（右移同理）
```
### 3.3 inc、dec
这两个指令同样非常简单，就是自增和自减，等价于`a++`和`a--`
但是需要注意的是，如果发生越界，会进行进位或借位，比如：
* 当AX=0000时，执行`dec ax`后，AX会变成FFFF，即借了一位，变成了10000 - 1
* 当AX=FFFF时，执行`inc ax`后，AX会变成0000，即进了一位，变成了0000
### 3.4 ne
取反指令，输入`neg ax`即可，可以用来获取一个数的**补码**，比如输入以下命令：
```asm fold
mov ax,0002
neg ax
```
执行后，AX寄存器的值变为FFFE，计算公式为：先算它的反码，再+1
## 四、DS 数据段地址
> data sequence 

DS是数据段地址寄存器，用来指向内存中的数据
比如当前DS=21F0，而内存的21F0:0060到21F0:0061的位置的值分别是12 34，执行以下指令：
```asm fold
mov ax,[60]
```
它的执行过程如下：
1. DS寄存器地址是21F0，因此会以它作为段地址从内存中寻址
2. 偏移地址是60，因此将段地址和偏移地址进行合成，得到的内存地址即是21F0:0060
3. 由于AX寄存器是16个字节，因此也会将内存中的16位数据复制到AX寄存器
4. **注意，内存中12是低地址，而34是高地址，因此会将12复制到AL，将34复制到AH**
5. 执行完后，AX寄存器的值为3412

```ad-note
* 除了mov指令外，同样也可以执行`add`指令，如`add ax,[60]`
* 也可以只对高或低位寄存器进行操作，比如：`mov ax,[60]`
* 不能直接对DS寄存器进行赋值，必须通过寄存器来，比如：`mov ds,ax`
```
## 五、CS:IP 代码段地址
> code sequence

跟DS寄存器类似，CS:IP指向的是代码段地址，它指向的数据是可以被执行的；
比如当我们输入`mox ax,1000`时，它就会在`CS:IP`指向的位置将我们的汇编指令**转成机器码**进行存放，此时我们使用`d 073F:0100`查看时，就会看到三个字节的机器码
```ad-note
* 在计算机中，代码本身也是数据，它跟内存中的数据实际是没有区分的，仅仅靠不同的寄存器来区别
```
### jmp
跳转指令，有两种用法：
1. `jump 段地址:偏移地址`：修改CS:IP的值
2. `jump 寄存器`：修改IP的值，如`jump ax`则会将AX寄存器的值赋值给IP寄存器
## 六、SS:SP 栈地址
首先要搞清楚内存中的栈模型：
![image.png|161](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202401312227211.png)
即，高位字节会存放在高位地址，而低位字节会存放在低位地址；而**ss:sp**其实就相当于**栈顶指针**，指向当前栈顶的元素，比如上图中就是23所对应的地址
### push
该指令是压栈命令，比如执行`push ax`，就会将ax寄存器中的值压入栈中，同时**栈顶指针会向上（即低位地址）移动**
此外，还可以使用`push [偏移地址]`的方式，将DS段地址寄存器指向的地址中的数据，压入栈中
### pop
该指令是出栈指令，比如执行`pop bx`，就会将ax寄存器中的值移出栈，并按照高低位来分配给bx寄存器，同时**栈顶指针会向下（即高位地址）移动**
此外，跟入栈类似，还可以使用`pop [偏移地址]`的方式，将DS段地址寄存器指向的地址中的数据，移出栈
```ad-note
title: CPU是如何执行push和pop指令呢？
跟mov指令不一样的是，CPU执行push指令时，会先将SP-2，即移动到栈顶，然后再将数据进行入栈；pop则是先将SP+2，然后再将数据出栈
```

```ad-warning
title:栈顶越界问题
计算机实际上是不知道你所谓的“栈”这种结构，因此对栈并没有一个界限，而只是根据栈顶指针来进行标记，因此需要人为地来避免栈顶越界的情况
```
## 七、内存寻址指令
一共有三个寄存器和内存寻址相关，分别是：bx、di和si寄存器，它们既可以单独使用，也可以搭配使用
### bx + i
当我们使用`mov ax,[bx+i]`命令时，此时就会以DS寄存器为段地址，以BX+i为偏移地址，来赋值给AX寄存器，比如：
* 此时ds为2000，bx寄存器为1000，且内存2000:0000位置的数据为：12 34 AB
* 当输入`mov ax,[bx+1]`时，就会把2000:0001的数据赋值给AX，即34 AB
* 又由于AB为高位数据，34为低位数据，故执行完后AX寄存器的值为AB34

```ad-note
* 只有BX寄存器可以这样操作，如果输入mox ax,[ax+1]会报错
* bx只能和数字相加，不能和普通寄存器相加，比如mov ax,[bx+ax]
```
### di、si
这两个寄存器的作用和bx寄存器类似，可以用来实现**间接寻址**，比如：
* [bx + di / si + i]：可以实现两个寄存器相加进行寻址
* [di / si + i]：单个寄存器也可以实现间接寻址

```ad-note
但是不允许di和si同时相加，比如[bx+di+si]
```
### bp
该寄存器的作用和bx、di、si是一样的，唯一不同的是，如果没有显式指定它的段地址，默认会取**ss寄存器的值作为段地址**，即栈段寄存器
### 总结
* bx和bp寄存器不能同时使用
* di和si寄存器不能同时使用
* 不管是写成直接相加的形式，还是数组的形式，本质都是加起来*
![image.png|525](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202402081611248.png)

```ad-tip
是否有一种恍然大悟的感觉？这不就是**指针的本质吗？**
```

## 八、标志寄存器
使用debug模式下，会发现13个寄存器中并没有这个所谓的标志寄存器，实际上它是在这个位置：
![image.png|695](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202402081625995.png)
### ZF 是否为零
ZERO FLAG，用来标记计算结果是否为0，当显示ZR，表示是0，当显示NZ时，表示非0
### PF 奇偶标记
PO表示有奇数个1，PE表示有偶数个1
### SF 正负标记
PL表示为正数，NG表示为负数
### CF 进位标记
NC表示没有进位，CY表示有进位
### OF 溢出标记
OV表示溢出，NV表示没有溢出
## 九、循环指令
在汇编语言中使用`loop`指令来实现循环功能，下面以一个例子来说明：
```asm fold
assume cs:codesg
codesg segment
    mov ax,2
    mov cx,11
    s:
        add ax,ax
        loop s
    int 21H
codesg ends
end
```
执行步骤：
1. 将AX寄存器的值设置为2
2. 将CS寄存器的值设置为11
3. 将AX寄存器的值和AX寄存器的值相加
4. CX寄存器的值先减1，然后执行循环，直到BX寄存器的值为0，因此一共会执行10 +  1 = 11次
5. 最终AX寄存器的值会变为2048

注意点：
* 循环的本质是**不断重复改变IP寄存器的值**，比如上面的第6行的指令是存放在6000:1024的位置，难么等执行循环指令时，就会不断地将IP寄存器的值重置为1024，直到BX寄存器的值变为0，才会继续向下执行指令，因此这些指令存放的内存位置实际上是连续的

```ad-note
在debug模式下，可以使用`p`来跳过循环
```

## 其他指令
### nop
该指令是空指令，用来占位使用，占用一个字节，输入`nop`即可，后续可以用来将一些代码段移动到空指令处
### xchg
交换指令，可以用来交换两个寄存器的数据，比如指定`xchg ax,bx`指令，即可交换AX和BX寄存器的数据，这样做的好处是，可以不使用中间寄存器来存放中间值
## 编译与链接
如果我们要使用汇编语言编写程序，需要以下几步：
① 编写汇编代码，注意需要用`asm`作为后缀
② 使用`masm`来进行编译
③ 使用`link`来连接，最终生成`.exe`后缀文件
④ 在debug模式下，可以使用命令`debug 文件名.exe`来打开
## 附录
### 寄存器中英对照表
| 简写 | 英文 | 含义 |
| ---- | ---- | ---- |
| AH&AL | accumulator | 累加寄存器 |
| BH&BL | base | 基址寄存器 |
| CH&CL | count | 计数寄存器 |
| SP | Stack Pointer | 堆栈指针寄存器 |
| BP | Base Pointer | 基址指针寄存器 |
| SI | Source Index | 源变址寄存器 |
| DI | Destination Index | 目的变址寄存器 |
| IP | Instruction Pointer | 指令指针寄存器 |
| CS | Code Segment | 代码段寄存器 |
| DS | Data Segment | 数据段寄存器 |
| SS | Stack Segment | 堆栈段寄存器 |
