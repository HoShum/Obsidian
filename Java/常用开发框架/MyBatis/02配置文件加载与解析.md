# 配置文件加载与解析

基础篇中讲解了MyBatis的配置，这里就来看看MyBatis是如何加载和解析这些配置的

首先从下面两行代码作为入口

```java
  InputStream xml = Resources.getResourceAsStream("mybatis-config.xml");
  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(xml);
```

## 1、读取配置文件

上面代码 Resources.getResourceAsStream("mybatis-config.xml")

点进去就会发现，是通过一个叫ClassLoaderWrapper的包装类来读取的，其核心逻辑如下

```java
//ClassLoaderWrapper  
public InputStream getResourceAsStream(String resource, ClassLoader classLoader) {
    return getResourceAsStream(resource, getClassLoaders(classLoader));
  }
```

上面的getClassLoaders其实就是新建了几个不同的ClassLoader

```java
//ClassLoaderWrapper 
InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) {
  for (ClassLoader cl : classLoader) {
    if (null != cl) {
      // try to find the resource as passed
      InputStream returnValue = cl.getResourceAsStream(resource);
      // now, some class loaders want this leading "/", so we'll add it and try again if we didn't find the resource
      if (null == returnValue) {
        returnValue = cl.getResourceAsStream("/" + resource);
      }
      if (null != returnValue) {
        return returnValue;
      }
    }
  }
  return null;
}
```

>   学到的技巧：可以通过ClassLoader来读取流，获取配置文件

## 2、解析配置文件

显然，从上面读取到的仅仅是二进制的流，而接下来要做的，则是将流解析成xml文件

```java
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(xml);
```

点进build，会来到下面这个方法

```java
public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
        return build(parser.parse());
    } // catch finally ......
}
```

>   可能你会问，这里的environment和properties是啥，目前都是null~

很显然，XMLConfigBuilder的职责就是用来将流解析成XML配置文件的

### 2.1 BaseBuilder

很容易能想到，MyBatis要解析的东西很多，而不只是XML配置文件，还有比如Mapper文件，所以MyBatis将其抽象为BaseBuilder类

```java
public abstract class BaseBuilder {
  protected final Configuration configuration;
  protected final TypeAliasRegistry typeAliasRegistry;
  protected final TypeHandlerRegistry typeHandlerRegistry;

  public BaseBuilder(Configuration configuration) {
    this.configuration = configuration;
    this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();
    this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();
  }
//忽略其他
}
```

没错，这个Configuration就是存放了MyBatis的所有配置，当XMLConfigBuilder创建时，会先生成一个空的Configuration，然后再进一步解析并设置这些配置

### 2.2 XMLConfigBuilder 

由于解析XML配置文件的核心逻辑并不在BaseBulider中，所以我们回到了XMLConfigBuilder

```java
//刚才new XMLConfigBuilder之后，就会进入到这个构造器
public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {
  //注意这里会new一个XPathParser，然后就跳到了下面的那个构造器
  this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);
}

private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
  //可以看到，会先生成一个空的Configuration
  super(new Configuration());
  ErrorContext.instance().resource("SQL Mapper Configuration");
  this.configuration.setVariables(props);
  this.parsed = false;
  this.environment = environment;
  this.parser = parser;
}
```

这里创建的XPathParser是用来解析XML文件的

#### 2.2.1 parse()

当创建完XMLConfigBuilder后，就会调用其parse()方法来解析Configuration

```java
public Configuration parse() {
  //保证只会解析一次
  if (parsed) {
    throw new BuilderException("Each XMLConfigBuilder can only be used once.");
  }
  parsed = true;
  //这里就是重点，用来解析xml
  parseConfiguration(parser.evalNode("/configuration")); //显然，这里解析的是xml文件中用configuration标签
  return configuration;
}
```

#### 2.2.2 XPathParser#evalNode

这里先把刚才的配置文件粘贴过来

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <setting name="logImpl" value="LOG4J"/>
    </settings>
  	<properties resource="jdbc.propertis"/>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${database.driver}"/>
                <property name="url" value="${database.url}"/>
                <property name="username" value="${database.username}"/>
                <property name="password" value="${database.password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="mapper/department.xml"/>
    </mappers>
</configuration>
```

其实可以看到，xml文件本身也是类似树一样的结构，大标签中嵌套子标签，并且每个标签可以定义属性

而XPathParser这个类的作用，就是将二进制流解析成一棵xml树，树的每个节点都是一个`Node`，注意，这个Node并不是MyBatis提供的，而是属于`org.w3c.dom`，我们所熟知的DOM对象

但是MyBatis为了拓展其属性，于是又封装了一层，叫**XNode**

```java
public class XNode {
  //可以看到这个就是原生的Node
  private final Node node;
  private final String name;
  private final String body;
  //property标签中的key
  private final Properties attributes;
  //property标签中的value
  private final Properties variables;
  private final XPathParser xpathParser;

  public XNode(XPathParser xpathParser, Node node, Properties variables) {
    this.xpathParser = xpathParser;
    this.node = node;
    this.name = node.getNodeName();
    this.variables = variables;
    this.attributes = parseAttributes(node);
    this.body = parseBody(node);
  }
//.....省略
}
```

至于为什么这样做呢，原因也很简单，因为MyBatis是支持动态配置的，比如将上面的数据库用户名和密码改成如下：

```xml
<dataSource type="POOLED">
    <property name="driver" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</dataSource>
```

显然原生的Node并不支持解析动态属性值，而是由XNode的**占位符解析器**进行解析，当解析完后，就会把对应的key和value值设置到两个Properties属性中

接下来再看回XPathParser是如何解析每个节点的

```java
public XNode evalNode(String expression) {
    return evalNode(document, expression);
}

public XNode evalNode(Object root, String expression) {
    Node node = (Node) evaluate(expression, root, XPathConstants.NODE);
    if (node == null) {
        return null;
    }
  	//可以看到会包装成XNode
    return new XNode(this, node, variables);
}

private Object evaluate(String expression, Object root, QName returnType) {
    try {
        // 委托javax的XPath解析xml，同样不是MyBatis提供的
        return xpath.evaluate(expression, root, returnType);
    } catch (Exception e) {
        throw new BuilderException("Error evaluating XPath.  Cause: " + e, e);
    }
}
```

#### 2.2.2.3 parseConfiguration(XNode node)

经过上面的解析，已经把二进制流转成一棵XNode树，接下来自然是将它转成Configuration

```java
private void parseConfiguration(XNode root) {
    try {
        propertiesElement(root.evalNode("properties"));
        Properties settings = settingsAsProperties(root.evalNode("settings"));
        loadCustomVfs(settings);
        loadCustomLogImpl(settings);
        typeAliasesElement(root.evalNode("typeAliases"));
        pluginElement(root.evalNode("plugins"));
        objectFactoryElement(root.evalNode("objectFactory"));
        objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
        reflectorFactoryElement(root.evalNode("reflectorFactory"));
        settingsElement(settings);
        // read it after objectFactory and objectWrapperFactory issue #631
        environmentsElement(root.evalNode("environments"));
        databaseIdProviderElement(root.evalNode("databaseIdProvider"));
        typeHandlerElement(root.evalNode("typeHandlers"));
        mapperElement(root.evalNode("mappers"));
    } catch (Exception e) {
        throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
    }
}
```

对照配置文件，其实就解析每个标签，并设置到对应的属性

下面就来看几个属性的解析过程

#### propertiesElement 解析properties

```java
private void propertiesElement(XNode context) throws Exception {
    if (context != null) {
        //解析所有的子property标签（详见下面代码）
        Properties defaults = context.getChildrenAsProperties();
      	//获取resource属性
        String resource = context.getStringAttribute("resource");
      	//获取url属性
        String url = context.getStringAttribute("url");
        if (resource != null && url != null) {
            // 二者不可兼得
            // throw ex ......
        }
      	//读取resource指向的properties文件
        if (resource != null) {
            defaults.putAll(Resources.getResourceAsProperties(resource));
        //通过url来读取配置文件
        } else if (url != null) {
            defaults.putAll(Resources.getUrlAsProperties(url));
        }
        //编程式加载的配置属性值
        Properties vars = configuration.getVariables();
        if (vars != null) {
            defaults.putAll(vars);
        }
        //将配置属性值放入解析器、全局配置中
        parser.setVariables(defaults);
        configuration.setVariables(defaults);
    }
}
```

```java
public Properties getChildrenAsProperties() {
  Properties properties = new Properties();
  for (XNode child : getChildren()) {
    String name = child.getStringAttribute("name");
    String value = child.getStringAttribute("value");
    if (name != null && value != null) {
      properties.setProperty(name, value);
    }
  }
  return properties;
}
```

这里可以得出一个结论，就是MyBatis读取配置时，**编程式优先级最高，其次是properties/url文件，最后才是配置文件内**

#### typeAliasesElement 注册类型别名

这里需要先讲一下这个别名是干嘛的，比如当我们这样配置后：

```xml
<typeAliases>
  <!-- 1、typeAlias:为某个java类型起别名
      type:指定要起别名的类型全类名;默认别名就是类名小写；employee
      alias:指定新的别名
   -->
   <typeAlias type="com.example.mybatis.bean.Employee" alias="emp"/> 
</typeAliases>
```

那么当我们写SQL的时候，就可以使用emp来代替Employee

```xml
<select id="getEmpById" resultType="emp">
  select * from tbl_employee where id = #{id}
</select>
```

>    另外，根据官方文档的描述，还可以搭配`@Alias`注解，使用`<package>`标签来指定包下的类的别名

接下来回到解析方法

```java
private void typeAliasesElement(XNode parent) {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            // 处理package的包扫描指定别名
            if ("package".equals(child.getName())) {
                String typeAliasPackage = child.getStringAttribute("name");
                //这里会扫描包路径下所有的类，并注册它们的别名
                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
            } else {
                // 处理typeAlias标签的逐个定义
                String alias = child.getStringAttribute("alias");
                String type = child.getStringAttribute("type");
                try {
                    Class<?> clazz = Resources.classForName(type);
                    if (alias == null) {
                        typeAliasRegistry.registerAlias(clazz);
                    } else {
                        typeAliasRegistry.registerAlias(alias, clazz);
                    }
                } catch (ClassNotFoundException e) {
                    throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
                }
            }
        }
    }
}
```

另外，这里可以看到，MyBatis默认下已经注册了一些类的别名，放到了TypeAliasRegistry这个类下

```java
public class TypeAliasRegistry {

  private final Map<String, Class<?>> typeAliases = new HashMap<>();

  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);
//...以下省略
  }
}
```

这样也可以解释到，为什么我们日常开发时，直接写类名而不是全类名，也可以解析到，MyBatis真是用心良苦啊！

#### pluginElement 注册插件

```java
private void pluginElement(XNode parent) throws Exception {
  if (parent != null) {
      for (XNode child : parent.getChildren()) {
        	//注意，这里是解析拦截器标签
          String interceptor = child.getStringAttribute("interceptor");
          Properties properties = child.getChildrenAsProperties();
          // 直接创建拦截器对象
          Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();
          // 拦截器的属性赋值
          interceptorInstance.setProperties(properties);
          configuration.addInterceptor(interceptorInstance);
      }
  }
}
```

#### environmentsElement 数据源环境配置

```java
private void environmentsElement(XNode context) throws Exception {
    if (context != null) {
        if (environment == null) {
            // 从default中取出默认的数据库环境配置标识
            environment = context.getStringAttribute("default");
        }
        for (XNode child : context.getChildren()) {
            String id = child.getStringAttribute("id");
            // 只会构造默认的数据库环境配置
            if (isSpecifiedEnvironment(id)) {
                // 解析transactionManager标签，生成TransactionFactory
                TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager"));
                // 解析dataSource标签，生成DataSource
                DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource"));
                DataSource dataSource = dsFactory.getDataSource();
                // 简单的建造器，构造出Environment对象
                Environment.Builder environmentBuilder = new Environment.Builder(id)
                    .transactionFactory(txFactory)
                    .dataSource(dataSource);
                configuration.setEnvironment(environmentBuilder.build());
            }
        }
    }
}
```

很简单，只是这个标签嵌套两个子标签而已

#### typeHandlerElement 类型处理器

同样是支持包扫描和逐个注册

```java
private void typeHandlerElement(XNode parent) {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            // 包扫描
            if ("package".equals(child.getName())) {
                String typeHandlerPackage = child.getStringAttribute("name");
                typeHandlerRegistry.register(typeHandlerPackage);
            } else {
                // 逐个注册TypeHandler
                String javaTypeName = child.getStringAttribute("javaType");
                String jdbcTypeName = child.getStringAttribute("jdbcType");
                String handlerTypeName = child.getStringAttribute("handler");
                Class<?> javaTypeClass = resolveClass(javaTypeName);
                JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
                Class<?> typeHandlerClass = resolveClass(handlerTypeName);
                if (javaTypeClass != null) {
                    if (jdbcType == null) {
                        typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);
                    } else {
                        typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
                    }
                } else {
                    typeHandlerRegistry.register(typeHandlerClass);
                }
            }
        }
    }
}
```

#### mapperElement 解析mapper

```java
private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            // 包扫描Mapper接口
            if ("package".equals(child.getName())) {
                String mapperPackage = child.getStringAttribute("name");
                configuration.addMappers(mapperPackage);
            } else {
                String resource = child.getStringAttribute("resource");
                String url = child.getStringAttribute("url");
                String mapperClass = child.getStringAttribute("class");
                // 处理resource加载的mapper.xml
                if (resource != null && url == null && mapperClass == null) {
                    ErrorContext.instance().resource(resource);
                    InputStream inputStream = Resources.getResourceAsStream(resource);
                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
                    mapperParser.parse();
                } else if (resource == null && url != null && mapperClass == null) {
                    // 处理url加载的mapper.xml
                    ErrorContext.instance().resource(url);
                    InputStream inputStream = Resources.getUrlAsStream(url);
                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
                    mapperParser.parse();
                } else if (resource == null && url == null && mapperClass != null) {
                    // 注册单个Mapper接口
                    Class<?> mapperInterface = Resources.classForName(mapperClass);
                    configuration.addMapper(mapperInterface);
                } else {
                    throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
                }
            }
        }
    }
}
```

这里可以发现，除了包扫描和单个注册外，另外两个方法还会进一步进行对mapper.xml进行解析，这里留在后续讲解

到这里为止，MyBatis就完成了对配置文件的加载和解析~
